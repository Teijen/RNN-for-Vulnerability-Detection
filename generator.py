#!/usr/bin/env python3
import sys
import os
import random 
import string
from pathlib import Path 
import numpy as np
import re

def writeToFile(headers, main_method, declarations, calls, functions, num_binaries, num_functions, data_folder, declarations_vuln, calls_vuln, funcions_vuln):
    # This part is for writing the binaries chose to have 3-6 total functions where 1 is vulnerable, rest is benign
    # Generate list with 120 random 12 char strings
    random_string_names = [''.join(random.choices(string.ascii_lowercase, k=12)) for name in range(0,120)]
    # Change each declaration to the new random string
    for rsn in range(len(declarations)):
        declarations[rsn] = re.sub('(?<=\ )(.*)(?=\()', random_string_names[rsn], declarations[rsn])
        calls[rsn] = re.sub('^[^(]+', random_string_names[rsn], calls[rsn])
        # Keep the formating clean with a tab prepended to the function call
        calls[rsn] = ''.join(('\t',calls[rsn]))
        functions[rsn][0] = re.sub('(?<=\s).*(?=\()', random_string_names[rsn], functions[rsn][0])

    # Do the same for the vulnerable declarations, calls and functions
    if(sys.argv[3] == 'V'):
        random_string_names_vul = [''.join(random.choices(string.ascii_lowercase, k=12)) for name in range(0,120)]
        for rsnv in range(len(declarations_vuln)):
            declarations_vuln[rsnv] = re.sub('(?<=\ )(.*)(?=\()', random_string_names_vul[rsnv], declarations_vuln[rsnv])
            calls_vuln[rsnv] = re.sub('^[^(]+', random_string_names_vul[rsnv], calls_vuln[rsnv])
            # Keep the formating clean with a tab prepended to the function call
            calls_vuln[rsnv] = ''.join(('\t',calls_vuln[rsnv]))
            functions_vuln[rsnv][0] = re.sub('(?<=\s).*(?=\()', random_string_names_vul[rsnv], functions_vuln[rsnv][0])

    for i in range(int(num_binaries)):
        # Pick a random subset of size num_functions and create .c files from those chosen
        vuln_index = -1
        loop_count = 0
        if sys.argv[3] == 'V':
            chosen = np.random.choice(len(declarations), size=int(num_functions)-1, replace=False)
            chosen_vul_function = np.random.choice(len(declarations_vuln), 1, replace=False)
            vuln_index = random.randrange(0, int(num_functions), 1)
            # print(chosen, chosen_vul_function, vuln_index)
        else:
            chosen = np.random.choice(len(declarations), size=int(num_functions), replace=False)
            # print(chosen) 

        file_to_create = data_folder / ("test_file"+"_"+str(num_functions)+"_"+str(i)+".c")
        f = open(file_to_create, "w+")
        # Write headers
        f.write(headers)
        f.write('\n')
        # Write declarations 
        for j in range(len(chosen)):
            if j == vuln_index:
                f.write('//Vuln decl:\n')
                f.write(declarations_vuln[chosen_vul_function[0]])
                
            f.write(declarations[chosen[j]])
        if vuln_index > j:
            f.write('//Vuln decl:\n')
            f.write(declarations_vuln[chosen_vul_function[0]])
        f.write('\n')
        # Write main
        for k in range(len(main_method)):
            # Write calls
            if k == 0:
                f.write(main_method[k])
                f.write('\n')
                for l in range(len(chosen)):
                    if l == vuln_index:
                        f.write('\t//Vuln call:\n')
                        f.write(calls_vuln[chosen_vul_function[0]])
                    f.write(calls[chosen[l]])
                if vuln_index > l:
                        f.write('\t//Vuln call:\n')
                        f.write(calls_vuln[chosen_vul_function[0]])
            else: 
                f.write(main_method[k])
        f.write('\n')
        # Write functions
        for m in range(len(chosen)):
            if m == vuln_index:
                f.write('//Vuln function:\n')
                for v in range(len(functions_vuln[chosen_vul_function[0]])):
                    f.write(functions_vuln[chosen_vul_function[0]][v])
                f.write('\n')
            for n in range(len(functions[chosen[m]])):
                f.write(functions[chosen[m]][n])
        if vuln_index > m:
            f.write('//Vuln function:\n')
            for v in range(len(functions_vuln[chosen_vul_function[0]])):
                f.write(functions_vuln[chosen_vul_function[0]][v])
            f.write('\n')
        f.write('\n')
        print('Generated sample: test_file' + "_" +str(num_functions)+"_"+str(i)+".c")
    f.close()

def readFile(path):
    f = open(path, "r")
    if f.mode == 'r':
        lines = f.readlines()

    f.close()
    return lines 
def exportDeclarations(lines):
    declarations = []
    # find indexes where the function declacations recide
    start_function_declaration = lines.index('/*Start declaration*/\n') + 1
    end_function_declaration = lines.index('/*End declaration*/\n') 

    # append source code to declaration list  
    for i in range(start_function_declaration,end_function_declaration):
        declarations.append(lines[i])

    return declarations 

def exportFunctionCalls(lines):
    full_call_stack = []
    start_function_call = lines.index('\t/*Call start*/\n')+1
    end_function_call = lines.index('\t/*Call end*/\n')
    
    for i in range(start_function_call ,end_function_call ):
        full_call_stack.append(lines[i])

    return full_call_stack


def exportFullFunctions(lines):
   
    function_start_indexes = []
    function_end_indexes = []
    full_functions = []
    
    # Used comments as tokens to help lookup indexes in lines
    substrStart = 'funcstart'
    substrEnd = 'funcend'

    # Find start and end lines for functions 
    for index, line in enumerate(lines):
        if substrStart in line:
            function_start_indexes.append(index+1)
        if substrEnd in line:
            function_end_indexes.append(index)

    # append full methods to list
    for i in range(len(function_start_indexes)):
        tmpList = []
        for j in range(function_start_indexes[i], function_end_indexes[i]):
            tmpList.append(lines[j])
        full_functions.append(tmpList) 

    return full_functions


if __name__=="__main__":

    '''
    Usage: 
    argv[1]: Number of binaries to create (1-N)
    argv[2]: Number of functions to use 3-6 
    argv[3]: B / V for creating pure benign, and V for including a vulnerable function as well 
    '''
    
    headers = '#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n'
    main_method = ['int main(int argc, char* argv[]){\n', '    return 0;\n','}\n']

    # Need the benign data for both B and V files :
    data_folder_benign = Path("./CompiledPrograms/Benign")
    data_folder_vuln = Path("./CompiledPrograms/Vulns")

    lines_benign = readFile("benignLib.c")
    decl_benign = exportDeclarations(lines_benign)
    calls_benign = exportFunctionCalls(lines_benign)
    functions_bengin = exportFullFunctions(lines_benign)
    # If benign, we can just use 
    if(sys.argv[3] == 'B'):
        print('Generating benign samples:\n')
        writeToFile(headers, main_method, decl_benign, calls_benign, functions_bengin, sys.argv[1], sys.argv[2], data_folder_benign, None, None, None)
    else:
        print('Generating vulnerable samples:\n')
        lines_vuln = readFile("vulnerabilityLib.c")
        decl_vuln = exportDeclarations(lines_vuln)
        calls_vuln = exportFunctionCalls(lines_vuln)
        functions_vuln = exportFullFunctions(lines_vuln)
        writeToFile(headers, main_method, decl_benign, calls_benign, functions_bengin, sys.argv[1], sys.argv[2], data_folder_vuln, decl_vuln, calls_vuln, functions_vuln)
