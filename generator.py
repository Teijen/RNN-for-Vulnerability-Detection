#!/usr/bin/env python3
import os
import random 

def writeToFile(headers, main_method, declarations, calls,  functions):

    # Create seed to choose random subset of functions 
    f = open("test_file.c", "w+")
    the_one = random.randrange(len(declarations))
    '''
    Can add method now to create single function programes that compile 
    keep this out for now. 
    '''


    # Write headers 
    for i in range(len(headers)):
        f.write(headers[i])
    f.write('\n')

    # Write declarations 
    for i in range(len(declarations)):
        f.write(declarations[i])
    f.write('\n')
    
    # Write main and function calls
    for i in range(len(main_method)):
        if i == 0:
            f.write(main_method[i])
            for call in calls:
                for j in range(len(call)):
                    f.write(call[j])
        else:
            f.write(main_method[i])
    # Write functions 
    for i in range(len(functions)):
        for j in range(len(functions[i])):
            f.write(functions[i][j])
        f.write('\n')
    # Close file 
    f.close()

def readFile(path):
    f = open(path, "r")
    if f.mode == 'r':
        lines = f.readlines()

    f.close()
    return lines 

def exportDeclarations(lines):
    declarations = []

    # find indexes where the function declacations recide
    start_function_declaration = lines.index('/*Start declalaction*/\n') + 1
    end_function_declaration = lines.index('/*End declalaction*/\n') 

    # append source code to declaration list  
    for i in range(start_function_declaration,end_function_declaration):
        declarations.append(lines[i])

    return declarations 

def exportFunctionCalls(lines):

    function_call_start_indexes= []
    function_call_end_indexes = [] # might not need this
    full_call_stack = []

    # Used comments as tokens to help lookup indexes in lines
    substrStart = 'Call start'
    substrEnd = 'Call end' # might not need this 
    
    # Find start and end lines for calls 
    for index, line in enumerate(lines):
        if substrStart in line:
            function_call_start_indexes.append(index+1)
        if substrEnd in line:
            function_call_end_indexes.append(index)
   
    # append calls to list
    
    for i in range(len(function_call_start_indexes)):
        tmpList = []
        for j in range(function_call_start_indexes[i], function_call_end_indexes[i]):
            tmpList.append(lines[j])
        full_call_stack.append(tmpList) 
    
    return full_call_stack
def exportFullFunctions(lines):
   
    function_start_indexes = []
    function_end_indexes = []
    full_functions = []
    
    # Used comments as tokens to help lookup indexes in lines
    substrStart = 'funcstart'
    substrEnd = 'funcend'

    # Find start and end lines for functions 
    for index, line in enumerate(lines):
        if substrStart in line:
            function_start_indexes.append(index+1)
        if substrEnd in line:
            function_end_indexes.append(index)

    # append full methods to list
    for i in range(len(function_start_indexes)):
        tmpList = []
        for j in range(function_start_indexes[i], function_end_indexes[i]):
            tmpList.append(lines[j])
        full_functions.append(tmpList) 

    return full_functions


if __name__=="__main__":

    # create a list of random names and use this list for writing and compiling below 

    headers = '#include <stdio.h>\n#include <string.h>\n #include <stdlib.h>\n'
    main_method = ['int main (int argc, char* argv[]){\n', '    return 0;\n','}\n']

    lines = readFile("vulnerabilityLib.c")
    decl = exportDeclarations(lines)
    calls = exportFunctionCalls(lines)
    functions = exportFullFunctions(lines)
    writeToFile(headers, main_method, decl, calls, functions)
    # Here is how to use the shell through python
    #os.system('gcc vulnerabilityLib.c -o vuln && ./vuln hello')