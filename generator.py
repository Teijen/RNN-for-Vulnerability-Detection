#!/usr/bin/env python3
import sys
import os
import random 
import string
from pathlib import Path 
import itertools

def writeToFile(headers, main_method, declarations, calls, functions, num_functions, num_bin ):
    data_folder = Path("./CompiledPrograms")
    num = int(num_functions)
    chosen_few = random.sample(range(len(decl)),num)
    print('These are the chosen indexes:', chosen_few)

    chosen_declaractions = []
    chosen_calls = []
    chosen_functions = []
    # Get the choosen indexes and save them to list for writing

    for chosen in chosen_few:
        chosen_declaractions.append(declarations[chosen])
        chosen_calls.append(calls[chosen])
        chosen_functions.append(functions[chosen])

    x = 0
    for r in itertools.product(chosen_few, chosen_few):
        file_to_create = data_folder / ("test_file"+"_"+str(num_functions)+"_"+str(x)+".c")
        f = open(file_to_create, "w+")
        # Write headers
        f.write(headers) 
        f.write('\n')
        # Write declarations
        f.write(declarations[r[0]])
        f.write(declarations[r[1]])
        f.write('\n')
        # Write main 
        for j in range(len(main_method)):
            # Write calls 
            if j == 0:
                f.write(main_method[j])
                f.write(calls[r[0]])
                f.write(calls[r[1]])
            else:
                f.write(main_method[j])
        for k in range(len(functions[r[0]])):
            f.write(functions[r[0]][k])
        for k in range(len(functions[r[1]])):
            f.write(functions[r[1]][k])
        x+=1
    f.close()

def readFile(path):
    f = open(path, "r")
    if f.mode == 'r':
        lines = f.readlines()

    f.close()
    return lines 
def exportDeclarations(lines):
    declarations = []

    # find indexes where the function declacations recide
    start_function_declaration = lines.index('/*Start declalaction*/\n') + 1
    end_function_declaration = lines.index('/*End declalaction*/\n') 

    # append source code to declaration list  
    for i in range(start_function_declaration,end_function_declaration):
        declarations.append(lines[i])

    return declarations 

def exportFunctionCalls(lines):
    full_call_stack = []
    start_function_call = lines.index('\t/*Call start*/\n')+1
    end_function_call = lines.index('\t/*Call end*/\n')
    
    for i in range(start_function_call ,end_function_call ):
        full_call_stack.append(lines[i])

    return full_call_stack


def exportFullFunctions(lines):
   
    function_start_indexes = []
    function_end_indexes = []
    full_functions = []
    
    # Used comments as tokens to help lookup indexes in lines
    substrStart = 'funcstart'
    substrEnd = 'funcend'

    # Find start and end lines for functions 
    for index, line in enumerate(lines):
        if substrStart in line:
            function_start_indexes.append(index+1)
        if substrEnd in line:
            function_end_indexes.append(index)

    # append full methods to list
    for i in range(len(function_start_indexes)):
        tmpList = []
        for j in range(function_start_indexes[i], function_end_indexes[i]):
            tmpList.append(lines[j])
        full_functions.append(tmpList) 

    return full_functions


if __name__=="__main__":

    # create a list of random names and use this list for writing and compiling below 
    '''
    Usage: 
    argv[1]: flagg for V / B vulnerable not vulnerable
    argv[2]: Number of functions included (1-120)
    argv[3]: Number of binaries to create (1-N)
    argv[4]: *optional for V,  number of V functions
    argv[5]: *optional for V, number of B functions  
    '''
    headers = '#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n'
    main_method = ['int main(int argc, char* argv[]){\n', '    return 0;\n','}\n']

    # Will use the V / B flag for reading either one or both libs
    lines = readFile("vulnerabilityLib.c")
    decl = exportDeclarations(lines)
    print('decl len', len(decl))
    calls = exportFunctionCalls(lines)
    print('call len', len(calls))
    functions = exportFullFunctions(lines)
    print('func len', len(functions))
    writeToFile(headers, main_method, decl, calls, functions, sys.argv[2], sys.argv[3])
    # Here is how to use the shell through python
    #os.system('gcc vulnerabilityLib.c -o vuln && ./vuln hello')